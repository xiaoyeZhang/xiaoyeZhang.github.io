<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>组件化之CocoaPods库的创建和管理</title>
    <link href="/2024/01/29/%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8BCocoaPods%E5%BA%93/"/>
    <url>/2024/01/29/%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8BCocoaPods%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h4 id="在iOS项目开发中，我们可以使用CocoaPods制作自己的远程私有库或者开源库，然后使pods方式来管理。CocoaPods库项目一般选择在github或者gittee、gitLab上创建开源库或者私有库。"><a href="#在iOS项目开发中，我们可以使用CocoaPods制作自己的远程私有库或者开源库，然后使pods方式来管理。CocoaPods库项目一般选择在github或者gittee、gitLab上创建开源库或者私有库。" class="headerlink" title="在iOS项目开发中，我们可以使用CocoaPods制作自己的远程私有库或者开源库，然后使pods方式来管理。CocoaPods库项目一般选择在github或者gittee、gitLab上创建开源库或者私有库。"></a>在iOS项目开发中，我们可以使用CocoaPods制作自己的远程私有库或者开源库，然后使pods方式来管理。CocoaPods库项目一般选择在github或者gittee、gitLab上创建开源库或者私有库。</h4><h3 id="一、制作自己的开源库"><a href="#一、制作自己的开源库" class="headerlink" title="一、制作自己的开源库"></a>一、制作自己的开源库</h3><p>CocoaPods库在Mac电脑中的地址：<code>/Users/xxx(用户目录)/.cocoapods/repos</code>,查看隐藏文件夹通<code>command + shift + .</code>快捷键，在目录里可以看到自己电脑里面包含的Cocoapods官方索引库和自己的索引库。</p><p><img src="/images/CocoaPods/6dcf28c0-be53-11ee-b320-1374ce0190c8.jpeg"></p><h4 id="1-在github创建自己的远程开源仓库"><a href="#1-在github创建自己的远程开源仓库" class="headerlink" title="1.在github创建自己的远程开源仓库"></a>1.在github创建自己的远程开源仓库</h4><p>我们在github中创建一个开源仓库，这里使用github为远程库</p><p><img src="/images/CocoaPods/f789ff80-be63-11ee-b320-1374ce0190c8.jpeg"></p><h4 id="2-创建本地代码仓库，cd进入你要创建模块的目录下"><a href="#2-创建本地代码仓库，cd进入你要创建模块的目录下" class="headerlink" title="2.创建本地代码仓库，cd进入你要创建模块的目录下"></a>2.创建本地代码仓库，cd进入你要创建模块的目录下</h4><h5 id="2-1-利用-pod-lib-create-来创建-库项目"><a href="#2-1-利用-pod-lib-create-来创建-库项目" class="headerlink" title="2.1 利用 pod lib create 来创建 库项目"></a>2.1 利用 pod lib create 来创建 库项目</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Shell">- 创建命令（此处NCCalendarPicker就是你的库名称，后面要用到，取名最好严谨一些）<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">pod lib create NCCalendarPicker</span><br><br>- 选择开源库平台<br>What platform do you want to use?? [ iOS / macOS ]<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">iOS</span><br><br>- 选择编程语言<br>What language do you want to use?? [ Swift / ObjC ]<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Swift</span><br><br>- 在你的项目中是否创建一个demo工程，为了方便测试，我选择了Yes<br>Would you like to include a demo application with your library? [ Yes / No ]<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Yes</span><br><br>- 测试框架选择哪一个<br>Which testing frameworks will you use? [ Specta / Kiwi / None ]<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">None</span><br><br>- 要不要做视图测试<br>Would you like to do view based testing? [ Yes / No ]<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Yes</span><br><br>- 类前缀名<br>What is your class prefix?<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">NC</span><br><br></code></pre></td></tr></table></figure><h5 id="2-2-不使用-pod-lib-create-利用Xcode创建"><a href="#2-2-不使用-pod-lib-create-利用Xcode创建" class="headerlink" title="2.2 不使用 pod lib create, 利用Xcode创建"></a>2.2 不使用 <code>pod lib create</code>, 利用Xcode创建</h5><h6 id="2-2-1-克隆远程项目到本地"><a href="#2-2-1-克隆远程项目到本地" class="headerlink" title="2.2.1 克隆远程项目到本地"></a>2.2.1 克隆远程项目到本地</h6><pre><code class="hljs">git clone https://github.com/xiaoyeZhang/NCCalendarPicker.git</code></pre><h6 id="2-2-2-点击Xcode菜单：File-New-Package"><a href="#2-2-2-点击Xcode菜单：File-New-Package" class="headerlink" title="2.2.2 点击Xcode菜单：File -&gt; New -&gt; Package"></a>2.2.2 点击Xcode菜单：File -&gt; New -&gt; Package</h6><p><img src="/images/CocoaPods/lC6Pbfle0nLuhLCp.png"></p><p><img src="/images/CocoaPods/OziiKrMXxebbX4sr3On.png"></p><h6 id="2-2-3-将写好的开源库源代码放入本地的Git仓库下的Sources目录下"><a href="#2-2-3-将写好的开源库源代码放入本地的Git仓库下的Sources目录下" class="headerlink" title="2.2.3 将写好的开源库源代码放入本地的Git仓库下的Sources目录下"></a>2.2.3 将写好的开源库源代码放入本地的Git仓库下的Sources目录下</h6><pre><code class="hljs">// 创建NCCalendarPicker.podspecpod spec create NCCalendarPicker</code></pre><h4 id="3-将自己的代码文件放到NCCalendarPicker-Classes-中"><a href="#3-将自己的代码文件放到NCCalendarPicker-Classes-中" class="headerlink" title="3.将自己的代码文件放到NCCalendarPicker&#x2F;Classes&#x2F;中"></a>3.将自己的代码文件放到NCCalendarPicker&#x2F;Classes&#x2F;中</h4><p>在Example中打开自己的工程，命令行执行pod install后, Example运行，如果没有问题，接下来编辑好<code>NCCalendarPicker.podspec</code>文件.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-type">Pod</span>::<span class="hljs-type">Spec</span>.new <span class="hljs-keyword">do</span> <span class="hljs-operator">|</span>s<span class="hljs-operator">|</span><br><br>  s.name          <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NCCalendarPicker&quot;</span> <span class="hljs-comment">//库名称</span><br>  s.version       <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0.0.1&quot;</span> <span class="hljs-comment">//库版本</span><br>  s.summary       <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Public&quot;</span> <span class="hljs-comment">//库简短描述</span><br>  s.description   <span class="hljs-operator">=</span> <span class="hljs-operator">&lt;&lt;-</span><span class="hljs-type">DESC</span><br>                    日历选择库<br>                    <span class="hljs-type">DESC</span>  <span class="hljs-comment">// 库具体描述</span><br>  s.homepage      <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://github.com/xiaoyeZhang/NCCalendarPicker.git&quot;</span> <span class="hljs-comment">//库首页地址</span><br>  s.license       <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MIT&quot;</span> <span class="hljs-comment">//协议，默认MIT</span><br>  s.author        <span class="hljs-operator">=</span> &#123; <span class="hljs-string">&quot;user_name&quot;</span> <span class="hljs-operator">=&gt;</span> <span class="hljs-string">&quot;email&quot;</span> &#125; <span class="hljs-comment">//作者</span><br>  s.platform      <span class="hljs-operator">=</span> :ios, <span class="hljs-string">&quot;11.0&quot;</span> <span class="hljs-comment">//库最低支持版本</span><br>  s.swift_version <span class="hljs-operator">=</span> &#x27;<span class="hljs-number">5.0</span>&#x27; <span class="hljs-comment">//库最低支持swift版本</span><br>  s.source        <span class="hljs-operator">=</span> &#123; :git <span class="hljs-operator">=&gt;</span> <span class="hljs-string">&quot;https://github.com/xiaoyeZhang/NCCalendarPicker.git&quot;</span>, :tag <span class="hljs-operator">=&gt;</span> <span class="hljs-string">&quot;#&#123;s.version&#125;&quot;</span> &#125;<br>  s.source_files  <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Classes&quot;</span>,<span class="hljs-string">&quot;Classes/**/*.swift&quot;</span> <span class="hljs-comment">//库文件路径</span><br>  s.exclude_files <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Classes/Exclude&quot;</span><br>  s.resources <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Resources/*&quot;</span> 资源文件地址<br>  s.user_target_xcconfig <span class="hljs-operator">=</span> &#123;<br>    &#x27;<span class="hljs-type">GENERATE_INFOPLIST_FILE</span>&#x27; <span class="hljs-operator">=&gt;</span> &#x27;<span class="hljs-type">YES</span>&#x27;<br>  &#125;<br>  s.pod_target_xcconfig <span class="hljs-operator">=</span> &#123;<br>    &#x27;<span class="hljs-type">GENERATE_INFOPLIST_FILE</span>&#x27; <span class="hljs-operator">=&gt;</span> &#x27;<span class="hljs-type">YES</span>&#x27;<br>  &#125;<br>  s.frameworks    <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UIKit&quot;</span>, <span class="hljs-string">&quot;Foundation&quot;</span> <span class="hljs-comment">//如果使用了原生库，在这里添加</span><br>  s.dependency   <span class="hljs-string">&quot;SnapKit&quot;</span> <span class="hljs-comment">//如果依赖了其他三方库，在这里添加</span><br>end<br></code></pre></td></tr></table></figure><p>上述填好之后进行下一步验证podspec文件有没有填对, 命令行cd到最外层的NCCalendarPicker文件夹.</p><pre><code class="hljs">1. pod lib lint / pod lib lint --allow-warnings // 执行命令检测本地项目是否通过编译如果检查正确了会提示NCCalendarPicker passed validation.2. 验证NCCalendarPicker.podspec文件(NCCalendarPicker为库名字)pod spec lint NCCalendarPicker.podspec如果检查正确了会提示NCCalendarPicker.podspec passed validation.</code></pre><h4 id="4-将项目代码提交到远程Github仓库中"><a href="#4-将项目代码提交到远程Github仓库中" class="headerlink" title="4.将项目代码提交到远程Github仓库中"></a>4.将项目代码提交到远程Github仓库中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;第一次提交 版本为0.0.1&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git push origin master</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git tag -a 0.0.1 -m <span class="hljs-string">&quot;v0.0.1封版&quot;</span> // 这里要跟podspec文件中的s.version保持一致</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git push origin 0.0.1(将tag提交到远程)</span><br><br></code></pre></td></tr></table></figure><p>自此代码就成功上传到了远程代码仓库中，接下来就是要把本地索引podspec添加到索引公有库</p><h4 id="5-push到Cocoapods"><a href="#5-push到Cocoapods" class="headerlink" title="5.push到Cocoapods"></a>5.push到Cocoapods</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell">使用push命令，发布自己的版本库到Cocoapods<br>pod trunk push NCCalendarPicker.podspec<br><br>如果依赖了第三方库，需要加上 --use-libraries 选项<br><br></code></pre></td></tr></table></figure><h3 id="二、push错误处理"><a href="#二、push错误处理" class="headerlink" title="二、push错误处理"></a>二、push错误处理</h3><p>如果 <code>pod trunk push</code>出现 <code>[!] You need to run pod trunk register to register a session first.</code>说明没有注册Cocoapods账号,输入以下命令注册.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">pod trunk register email &#x27;user_name&#x27; --verbose // 把email和user_name换成自己的邮箱和用户名<br></code></pre></td></tr></table></figure><p>会给邮箱发送确认邮件，在邮箱里点击链接同意就可以了，重新<code>pod trunk push NCCalendarPicker.podspec</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>掌握 Swift Package Manager（构建SPM包)</title>
    <link href="/2024/01/12/SPM(Swift%20Package%20Manager)%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AF%87/"/>
    <url>/2024/01/12/SPM(Swift%20Package%20Manager)%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h4 id="Swift-Package-Manager（Swift-包管理器，一般简称-SwiftPM-或者-SPM）是苹果官方（2016年随-Swift-3-0-一起发布）-提供的一个用于管理源代码分发的工具，旨在使分享代码和复用其他人的代码变得更加容易。该工具可以帮助我们编译和链接-Swift-packages（包），管理依赖关系、版本控制，以及支持灵活分发和协作（公开、私有、团队共享）等"><a href="#Swift-Package-Manager（Swift-包管理器，一般简称-SwiftPM-或者-SPM）是苹果官方（2016年随-Swift-3-0-一起发布）-提供的一个用于管理源代码分发的工具，旨在使分享代码和复用其他人的代码变得更加容易。该工具可以帮助我们编译和链接-Swift-packages（包），管理依赖关系、版本控制，以及支持灵活分发和协作（公开、私有、团队共享）等" class="headerlink" title="Swift Package Manager（Swift 包管理器，一般简称 SwiftPM 或者 SPM）是苹果官方（2016年随 Swift 3.0 一起发布） 提供的一个用于管理源代码分发的工具，旨在使分享代码和复用其他人的代码变得更加容易。该工具可以帮助我们编译和链接 Swift packages（包），管理依赖关系、版本控制，以及支持灵活分发和协作（公开、私有、团队共享）等"></a><strong>Swift Package Manager</strong>（Swift 包管理器，一般简称 SwiftPM 或者 SPM）是苹果官方（2016年随 Swift 3.0 一起发布） 提供的一个用于管理源代码分发的工具，旨在使分享代码和复用其他人的代码变得更加容易。该工具可以帮助我们编译和链接 Swift packages（包），管理依赖关系、版本控制，以及支持灵活分发和协作（公开、私有、团队共享）等</h4><h2 id="一-SwiftPM-（SPM）基本概念"><a href="#一-SwiftPM-（SPM）基本概念" class="headerlink" title="一. SwiftPM （SPM）基本概念"></a>一. SwiftPM （SPM）基本概念</h2><ul><li><p>什么是 Packages？</p><p>一个 package（包）由 Swift 源码文件和一个清单文件组成。这个清单文件被称为 <code>Package.swift</code>，它使用 <code>PackageDescription</code> 模块来定义包的名称和内容。一个包通常有一个或者多个 targets（目标），每个 target 指定一个 product（产品）并声明一个或者多个 dependencies（依赖）。</p></li><li><p>什么是 Products？</p><p>在 package（包）中的每一个 target（目标）最终可能构建成一个 library（库）或者一个 executable（可执行文件）作为其 product（产品）。库是包含可以被其他 Swift 代码引用的模块，可执行文件是一段可以被操作系统运行的程序。</p></li></ul><p>对于 SwiftPM 的一些<strong>基本概念</strong>，例如：Modules、Packages、Products、Dependencies、Targets 等，在 Swift.org <a href="https://link.juejin.cn/?target=https://swift.org/package-manager/" title="https://swift.org/package-manager/">官网</a>已经有非常详细的描述和定义</p><h2 id="二-如何创建SwiftPM-（SPM）项目？"><a href="#二-如何创建SwiftPM-（SPM）项目？" class="headerlink" title="二. 如何创建SwiftPM （SPM）项目？"></a>二. 如何创建SwiftPM （SPM）项目？</h2><h3 id="1-Xcode-14创建"><a href="#1-Xcode-14创建" class="headerlink" title="1. Xcode 14创建"></a>1. Xcode 14创建</h3><p>在 Xcode 的菜单栏中选择 “File”（文件）&gt; “New”（新建）&gt; “Package…”（包…）。</p><h3 id="2-命令行创建"><a href="#2-命令行创建" class="headerlink" title="2. 命令行创建"></a>2. 命令行创建</h3><p>使用 Swift Package Manager 创建新的 Swift 包相当简单，只需要运行 <code>swift package init</code> 命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> &lt;package name&gt;</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> &lt;package name&gt;</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">swift package init --<span class="hljs-built_in">type</span> library</span><br></code></pre></td></tr></table></figure><p>上述命令会创建一个新的库类型的 Swift 包，包名就是目录名。</p><h2 id="三-Swift-包的基本结构"><a href="#三-Swift-包的基本结构" class="headerlink" title="三. Swift 包的基本结构"></a>三. Swift 包的基本结构</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-type">MyPackage</span><br>    <span class="hljs-operator">├──</span> <span class="hljs-type">Package</span>.swift<br>    <span class="hljs-operator">├──</span> <span class="hljs-type">Sources</span><br>    <span class="hljs-operator">│</span>   <span class="hljs-operator">└──</span> <span class="hljs-type">MyPackage</span><br>    <span class="hljs-operator">│</span>       <span class="hljs-operator">├──</span> <span class="hljs-type">File1</span>.swift<br>    <span class="hljs-operator">│</span>       <span class="hljs-operator">└──</span> <span class="hljs-type">File2</span>.swift<br>    <span class="hljs-operator">└──</span> <span class="hljs-type">Tests</span><br>        <span class="hljs-operator">└──</span> <span class="hljs-type">MyPackageTests</span><br>            <span class="hljs-operator">├──</span> <span class="hljs-type">File1Tests</span>.swift<br>            <span class="hljs-operator">└──</span> <span class="hljs-type">File2Tests</span>.swift<br><br></code></pre></td></tr></table></figure><p>这里主要包含三个部分：</p><ul><li><p><code>Package.swift</code>：这是 Swift 包的配置文件，其中定义了包的名称、产品、依赖项等信息。</p></li><li><p><code>Sources</code>：这个目录包含了 Swift 包的源代码。</p></li><li><p><code>Tests</code>：这个目录包含了 Swift 包的测试代码。</p></li></ul><h2 id="四-配置SPM依赖"><a href="#四-配置SPM依赖" class="headerlink" title="四. 配置SPM依赖"></a>四. 配置SPM依赖</h2><p>在 <code>Package.swift</code> 文件中，我们可以声明当前包依赖的其他 Swift 包。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php">let package = <span class="hljs-title function_ invoke__">Package</span>(<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Example&quot;</span>, <br>    <span class="hljs-attr">platforms</span>: [<br>      .<span class="hljs-title function_ invoke__">iOS</span>(.v11)<br>    ],<br>    <span class="hljs-attr">products</span>: [<br>        .<span class="hljs-title function_ invoke__">library</span>(<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Example&quot;</span>,<br>            <span class="hljs-attr">targets</span>: [<span class="hljs-string">&quot;Example&quot;</span>]),<br>    ],<br>    <span class="hljs-attr">dependencies</span>: [<br>        .<span class="hljs-title function_ invoke__">package</span>(<span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://github.com/SnapKit/SnapKit.git&quot;</span>, .<span class="hljs-title function_ invoke__">upToNextMajor</span>(<span class="hljs-attr">from</span>: <span class="hljs-string">&quot;5.0.1&quot;</span>))<br>    ],<br>    <span class="hljs-attr">targets</span>: [<br>        .<span class="hljs-title function_ invoke__">target</span>(<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Example&quot;</span>,<br>            <span class="hljs-attr">dependencies</span>: [<span class="hljs-string">&quot;SnapKit&quot;</span>],<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;Sources&quot;</span><br>        ),<br>    ]<br>)<br><br></code></pre></td></tr></table></figure><p>在这个例子中，我们的 “Example” 包依赖于 “SnapKit”，它的源代码托管在 GitHub 上</p><h3 id="细说-Package-swift-文件"><a href="#细说-Package-swift-文件" class="headerlink" title="细说 Package.swift 文件"></a>细说 Package.swift 文件</h3><p><code>Package.swift</code> 是一个包描述文件，这里面定义了包的一些基本信息，如包的名称，产品，依赖项等。它使用 Swift 语言编写。</p><p>在 <code>Package</code> 对象中，我们可以定义以下内容：</p><ul><li><p><code>name</code>：这是你的包的名称。</p></li><li><p><code>platforms</code>：这定义了你的包支持的平台和版本。</p></li><li><p><code>products</code>：这定义了你的包提供的产品。一个产品可以是一个库或一个可执行文件。</p></li><li><p><code>dependencies</code>：这定义了你的包依赖的其他包。你需要提供每个依赖包的 URL 和版本。</p></li><li><p><code>targets</code>：这定义了你的包的构建目标。每个目标可以依赖于源文件和其他目标。</p></li></ul><p>以下是一个 <code>Package.swift</code> 的示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php">import PackageDescription<br><br>let package = <span class="hljs-title function_ invoke__">Package</span>(<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;NCCalendarPicker&quot;</span>,<br>    <span class="hljs-attr">platforms</span>: [<br>      .<span class="hljs-title function_ invoke__">iOS</span>(.v11)<br>    ],<br>    <span class="hljs-attr">products</span>: [<br>        .<span class="hljs-title function_ invoke__">library</span>(<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;NCCalendarPicker&quot;</span>,<br>            <span class="hljs-attr">targets</span>: [<span class="hljs-string">&quot;NCCalendarPicker&quot;</span>]),<br>    ],<br>    <span class="hljs-attr">dependencies</span>: [<br>        .<span class="hljs-title function_ invoke__">package</span>(<span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://github.com/SnapKit/SnapKit.git&quot;</span>, .<span class="hljs-title function_ invoke__">upToNextMajor</span>(<span class="hljs-attr">from</span>: <span class="hljs-string">&quot;5.0.1&quot;</span>))<br>    ],<br>    <span class="hljs-attr">targets</span>: [<br>        .<span class="hljs-title function_ invoke__">target</span>(<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;NCCalendarPicker&quot;</span>,<br>            <span class="hljs-attr">dependencies</span>: [<span class="hljs-string">&quot;SnapKit&quot;</span>],<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;Sources&quot;</span><br>        ),<br>    ]<br>)<br><br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为 “NCCalendarPicker” 的包，它在 iOS 11 及以上版本上运行，依赖于 “SnapKit”。</p><h3 id="解说-Package-swift-与项目目录的关系"><a href="#解说-Package-swift-与项目目录的关系" class="headerlink" title="解说 Package.swift 与项目目录的关系"></a>解说 Package.swift 与项目目录的关系</h3><p>除了 <code>Package.swift</code> 文件之外，Swift Package 通常还有以下目录结构：</p><ul><li><p><strong>Sources</strong>：这个目录包含所有的 Swift 源代码文件。每个 target（目标）在 <code>Sources</code> 目录中都有一个对应的子目录。例如，如果你在 <code>Package.swift</code> 文件中定义了一个名为 “Example” 的 target，那么你应该在 <code>Sources</code> 目录下创建一个同名的 “Example” 子目录，然后将这个 target 的所有源代码文件放在这个子目录中。</p></li><li><p><strong>Tests</strong>：这个目录包含所有的测试代码。和 <code>Sources</code> 目录类似，每个测试 target 在 <code>Tests</code> 目录中也有一个对应的子目录。</p></li></ul><p>因此，<code>Package.swift</code> 文件和目录结构是一一对应的。你在 <code>Package.swift</code> 文件中定义的每个 target，都应该在 <code>Sources</code> 或 <code>Tests</code> 目录中有一个对应的子目录。</p><h2 id="构建和运行"><a href="#构建和运行" class="headerlink" title="构建和运行"></a>构建和运行</h2><p>要构建和运行 Swift 包，我们可以使用 Swift Package Manager 的 <code>swift build</code> 和 <code>swift run</code> 命令。例如，要构建你的包，可以在终端中运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">swift build</span><br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>如果你的 Swift 包中包含了测试代码，可以使用 <code>swift test</code> 命令来运行这些测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">swift <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><h2 id="上传至-Github"><a href="#上传至-Github" class="headerlink" title="上传至 Github"></a>上传至 Github</h2><ul><li>创建 Git 仓库：</li></ul><p><img src="/images/SPM/e36884b0-aeb7-11ee-a1b8-f5a5b9e80723.jpeg?v=1&type=image"></p><p>建议勾选：『README』、『.gitignore』和『license』，然后点击『Create repository』。</p><ul><li>clone &amp;&amp; commit（建议打上 tag）：</li></ul><p><img src="/images/SPM/92acaeb0-aeb8-11ee-a1b8-f5a5b9e80723.png?v=1&type=image"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Swift Package Manager 是一个强大的工具，它能帮助我们更方便地管理 Swift 代码包，同时也使代码的分享和复用变得更加简单。掌握 SPM，你会发现在 Swift 开发中，无论是管理自己的代码，还是使用他人的代码，都变得非常方便。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>掌握 Swift Package Manager（使用SPM依赖包)</title>
    <link href="/2024/01/05/SPM(Swift%20Package%20Manager)%E4%BD%BF%E7%94%A8%E7%AF%87/"/>
    <url>/2024/01/05/SPM(Swift%20Package%20Manager)%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h4 id="至从苹果-WWDC-18-推出了-Swift-Package-Manager-后，我们不再只局限于使用-CocoaPods-和Carthage第三方包管理工具，现有项目还是会延续使用-CocoaPods，但新的项目，特别是打算完全使用-Swift-开发的项目，可以考虑使用-SPM-来作为包管理工具，也是一个不错的选择；当然，CocoaPods-与-SPM-共用也并不冲突，不过维护两份也是较麻烦的。"><a href="#至从苹果-WWDC-18-推出了-Swift-Package-Manager-后，我们不再只局限于使用-CocoaPods-和Carthage第三方包管理工具，现有项目还是会延续使用-CocoaPods，但新的项目，特别是打算完全使用-Swift-开发的项目，可以考虑使用-SPM-来作为包管理工具，也是一个不错的选择；当然，CocoaPods-与-SPM-共用也并不冲突，不过维护两份也是较麻烦的。" class="headerlink" title="至从苹果 WWDC 18 推出了 Swift Package Manager 后，我们不再只局限于使用 CocoaPods 和Carthage第三方包管理工具，现有项目还是会延续使用 CocoaPods，但新的项目，特别是打算完全使用 Swift 开发的项目，可以考虑使用 SPM 来作为包管理工具，也是一个不错的选择；当然，CocoaPods 与 SPM 共用也并不冲突，不过维护两份也是较麻烦的。"></a>至从苹果 WWDC 18 推出了 Swift Package Manager 后，我们不再只局限于使用 CocoaPods 和Carthage第三方包管理工具，现有项目还是会延续使用 CocoaPods，但新的项目，特别是打算完全使用 Swift 开发的项目，可以考虑使用 SPM 来作为包管理工具，也是一个不错的选择；当然，CocoaPods 与 SPM 共用也并不冲突，不过维护两份也是较麻烦的。</h4><h2 id="一、项目中集成"><a href="#一、项目中集成" class="headerlink" title="一、项目中集成"></a>一、项目中集成</h2><p>在 Xcode 的项目中选择 PROJECT，如图：</p><p><img src="/images/SPM/ff3573e0-aeb9-11ee-a1b8-f5a5b9e80723.jpeg?v=1&type=image"></p><p>这里，我选择 AFNetworking 的 Swift 版本：Alamofire，输入Alamofire的github地址：<a href="https://github.com/Alamofire/Alamofire">https://github.com/Alamofire/Alamofire</a></p><p><img src="/images/SPM/13146d80-aeba-11ee-a1b8-f5a5b9e80723.jpeg?v=1&type=image"></p><p>点击Add Package，等待获取Alamofire的源（可能会比较慢），获取成功后就会出现如下图：</p><p><img src="/images/SPM/15717050-aeba-11ee-a1b8-f5a5b9e80723.jpeg?v=1&type=image"></p><p>再点击 Add Package，添加源到项目中，会以下图方式展现：</p><p><img src="/images/SPM/13146d80-aeba-11ee-a1b8-f5a5b9e80723.jpeg?v=1&type=image"></p><h2 id="二、更新依赖"><a href="#二、更新依赖" class="headerlink" title="二、更新依赖"></a>二、更新依赖</h2><p>更新依赖也比较简单：菜单 -&gt;『File』-&gt; 『Swift Packages』-&gt;『Update to Latest Package Versions』即可，如下图：</p><p><img src="/images/SPM/e8dd9590-aeba-11ee-a1b8-f5a5b9e80723.jpeg?v=1&type=image"></p><h2 id="三、测试依赖源"><a href="#三、测试依赖源" class="headerlink" title="三、测试依赖源"></a>三、测试依赖源</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">import</span> Alamofire<br><br><span class="hljs-type">AF</span>.request(<span class="hljs-string">&quot;https://httpbin.org/get&quot;</span>).response &#123; response <span class="hljs-keyword">in</span><br>    <span class="hljs-built_in">debugPrint</span>(response)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行代码，结果如下：</p><p><img src="/images/SPM/37e3cf80-aebe-11ee-a1b8-f5a5b9e80723.jpeg?v=1&type=image"></p><h2 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h2><h3 id="4-1、源码存放位置"><a href="#4-1、源码存放位置" class="headerlink" title="4.1、源码存放位置"></a>4.1、源码存放位置</h3><p>我们可以通过『Show in Finder』直接打开源码所在的目录，如下图：</p><p><img src="/images/SPM/14397340-aebf-11ee-a1b8-f5a5b9e80723.jpeg?v=1&type=image"></p><p>实际上，这就是该项目在 Xcode 中编译缓存的地方。</p><p><img src="/images/SPM/111a31e0-aebf-11ee-a1b8-f5a5b9e80723.jpeg?v=1&type=image"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>每日一句 - 2023-12-04</title>
    <link href="/2023/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%8F%A5/"/>
    <url>/2023/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>我们永远不要在自己所看重的事情上，投入不切实际的期待，附加不着边际的价值。</p><p>因为人生唯一确定的就是不确定的人生，人生唯一恐惧的就是恐惧本身。</p><p>很多东西不是你能决定的，但是当你拥有这个剧本的时候，你要把它演好，你很难去创造一个属于你自己的剧本，</p><p>但是当剧本来临的时候，你要把它演好。</p><p>对于可控的事情要保持谨慎，对于不可控的事情要保持乐观，人只能做自己能力范围内的事情，你要接受这个事实，并且以乐观的心去应对这一切，做你该做的事，并且接受他的事与愿违</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Xcode 设置 SPM 全局代理(Proxifier)</title>
    <link href="/2023/12/04/Proxifier%20%E4%BB%A3%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <url>/2023/12/04/Proxifier%20%E4%BB%A3%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="一、前提"><a href="#一、前提" class="headerlink" title="一、前提"></a><strong>一、前提</strong></h3><p>目前 iOS 项目管理第三方库的方式有多种，这里使用的是官方推荐的<code>SPM</code>进行包管理，大部分开源项目都在<code>github</code>，不过如果使用<code>SPM</code>进行包管理，需要使用代理模式才可以进行下载。</p><p>目前使用的<code>ClashX</code>作为代理工具，Xcode 使用的是自带的 git，可是即使设置全局或控制台的代理都无法使<code>SPM</code>走代理模式。故我们可以使用 Proxifier 抓包工具进行全局网络代理设置。</p><h3 id="二、Xcode-自带-git"><a href="#二、Xcode-自带-git" class="headerlink" title="二、Xcode 自带 git"></a><strong>二、Xcode 自带 git</strong></h3><p>经过查询 Xcode 的使用的自带<code>git</code>程序为<code>com.apple.dt.Xcode.sourcecontrol.Git</code>，在<code>Xcode</code>里面的进行<code>SPM</code>下载第三方库的时候可以到控制台查看.具体命令行为<code>ps aux|grep com.apple.dt.Xcode</code>，显示结果如下：</p><p><img src="/images/Proxifier/7aafecc0-902a-11ee-a20b-a714d8de737e.jpeg?v=1&type=image"></p><h3 id="三、Proxifier-配置"><a href="#三、Proxifier-配置" class="headerlink" title="三、Proxifier 配置"></a>三、Proxifier 配置</h3><p>利用抓包软件<code>Proxifier</code>进行代理设置，该软件为<em>付费</em>，官网地址为<a href="https://www.proxifier.com/">Proxifier</a>，可以下载使用版本，后期也可以购买。</p><p>打开 Proxifier 之后会需要权限，需要输入系统密码授权，在网络部分会显示这两个菜单:</p><p><img src="/images/Proxifier/00b1b0f0-902c-11ee-a20b-a714d8de737e.jpeg?v=1&type=image"></p><p><img src="/images/Proxifier/9b6c2260-902c-11ee-a20b-a714d8de737e.jpeg?v=1&type=image"></p><p>然后打开<code>Proxies</code>，添加本机的代理端口，这里可以使用<code>http</code>或者<code>socks</code>，配置如下：</p><p><img src="/images/Proxifier/79da83b0-9240-11ee-a20b-a714d8de737e.jpeg?v=1&type=image"></p><p>这里使用的是本机<code>socks5</code>端口<code>7890</code>，然后再打开<code>Rules</code>进行规则配置，其中<code>Default</code>没法配置，默认直接走<code>Direct</code>即可(不然全都会走代理)，新增一个规则，添加应用程序<code>Xcode</code>，然后再把上面找到的<code>com.apple.dt.Xcode.sourcecontrol.Git</code>追加到后面去，下面<code>Action</code>添加刚才设置的<code>Proxy</code>即可，配置参照</p><p><img src="/images/Proxifier/b5cf7ba0-9240-11ee-a20b-a714d8de737e.jpeg?v=1&type=image"><img src="/images/Proxifier/bf39e9f0-9240-11ee-a20b-a714d8de737e.jpeg?v=1&type=image"></p><p>配置生效之后就可以看到<code>Xcode</code>里面<code>SPM</code>拉取<code>github</code>时候流量会走到代理，速度明显提升。</p><h5 id="最后来一波福利（proxifier-是收费的，下面免费提供-v2-v3-版本的注册码）"><a href="#最后来一波福利（proxifier-是收费的，下面免费提供-v2-v3-版本的注册码）" class="headerlink" title="最后来一波福利（proxifier 是收费的，下面免费提供 v2&#x2F;v3 版本的注册码）"></a>最后来一波福利（proxifier 是收费的，下面免费提供 v2&#x2F;v3 版本的注册码）</h5><p>proxifier for Mac 注册码</p><p><strong>V2：</strong></p><p><strong>P427L-9Y552-5433E-8DSR3-58Z68</strong></p><p><strong>V3：</strong></p><p><strong>3CWNN-WYTP4-SD83W-ASDFR-84KEA</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CocoaPods、Carthage、Swift Package Manager 对比</title>
    <link href="/2023/12/04/CocoaPods%E3%80%81Carthage%E3%80%81Swift%20Package%20Manager%20%E5%AF%B9%E6%AF%94/"/>
    <url>/2023/12/04/CocoaPods%E3%80%81Carthage%E3%80%81Swift%20Package%20Manager%20%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h3 id="一、iOS-管理第三方库工具有以下几种："><a href="#一、iOS-管理第三方库工具有以下几种：" class="headerlink" title="一、iOS 管理第三方库工具有以下几种："></a><strong>一、iOS 管理第三方库工具有以下几种：</strong></h3><h4 id="1-CocoaPods："><a href="#1-CocoaPods：" class="headerlink" title="1. CocoaPods："></a>1. CocoaPods：</h4><p>CocoaPods 是一个用 Ruby 编写的开源项目管理工具，它可以帮助 iOS、MacOS 和其他平台的开发者管理第三方库的依赖关系。它可以自动化完成下载、编译、安装和配置第三方库的工作，大大简化了开发者的工作流程。</p><h4 id="2-Carthage："><a href="#2-Carthage：" class="headerlink" title="2. Carthage："></a>2. Carthage：</h4><p>Carthage 是一个针对 iOS 应用程序的轻量级依赖管理器，和 CocoaPods 不同的是，它不会修改 Xcode 项目文件或者创建一个统一的工作区来管理第三方库，而是直接从 GitHub 或者其他 Git 仓库中下载源代码并编译成动态库供应用程序使用。</p><h4 id="3-Swift-Package-Manager："><a href="#3-Swift-Package-Manager：" class="headerlink" title="3. Swift Package Manager："></a>3. Swift Package Manager：</h4><p>Swift Package Manager 是 Apple 官方推出的依赖管理工具，它可以帮助开发者快速构建和共享 Swift 代码库，也可以管理应用程序的依赖关系。它可以通过 Git 或者其他源代码管理工具获取依赖库的代码，并在编译时进行构建和链接。</p><h3 id="二、中心化-VS-去中心化"><a href="#二、中心化-VS-去中心化" class="headerlink" title="二、中心化 VS 去中心化"></a>二、中心化 VS 去中心化</h3><p>相信大家都听过中心化这个词，通俗易懂的来讲，就是『（资源）集中式管理』：</p><ul><li><p>CocoaPods 是中心化的，因为所有的资源索引都集中在一个仓库中（下图 Master Repo 就代表 Pods）；</p><p><img src="/images/08407ab6a86c46fcbcdec5a1d0d958a0.webp"></p></li><li><p>SPM 和 Carthage 则是去中心化的，需要啥资源就自己去对应的仓库中下载；</p><p><img src="/images/5dc0bac402a24da7a61210b047c0df86.webp"></p></li></ul><h3 id="三、对比分析"><a href="#三、对比分析" class="headerlink" title="三、对比分析"></a><strong>三、对比分析</strong></h3><table><thead><tr><th align="center">-</th><th align="center"><strong>CocoaPods</strong></th><th align="center"><strong>Carthage</strong></th><th align="center"><strong>SPM</strong></th></tr></thead><tbody><tr><td align="center">原理</td><td align="center">Cocoapods 会将所有的依赖库都放到另一个名为 Pods 的项目中，然后让主项目依赖 Pods 项目</td><td align="center">自动将第三方框架编程为 Dynamic framework(动态库)</td><td align="center">Swift 构建系统集成在一起，可以自动执行依赖项的下载，编译和链接过程</td></tr><tr><td align="center">适用语言</td><td align="center">OC、Swift</td><td align="center">OC、Swift</td><td align="center">OC、Swift、C</td></tr><tr><td align="center">版本支持</td><td align="center">-</td><td align="center">iOS8+</td><td align="center">iOS8+</td></tr><tr><td align="center">支持库</td><td align="center">多,基本都支持</td><td align="center">大部分支持，但少于 CocoaPods</td><td align="center">多,基本都支持</td></tr><tr><td align="center">使用复杂度</td><td align="center">中等</td><td align="center">高</td><td align="center">简单</td></tr><tr><td align="center">项目入侵</td><td align="center">严重</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">源码可见</td><td align="center">可见</td><td align="center">不可见</td><td align="center">可见</td></tr><tr><td align="center">编译速度</td><td align="center">慢</td><td align="center">快</td><td align="center">首次较慢</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS - weak属性</title>
    <link href="/2023/11/29/weak%E5%B1%9E%E6%80%A7/"/>
    <url>/2023/11/29/weak%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>ARC 是自 iOS 5 之后增加的新特性，完全消除了手动管理内存的烦琐，编译器会自动在适当的地方插入适当的 retain、release、autorelease 语句。你不再需要担心内存管理,因为编译器为你处理了一切.</p><p>注意：ARC 是编译器特性，而不是 iOS 运行时特性(除了 weak 指针系统)，它也不是类似于其它语言中的垃圾回收器。因此 ARC 和手动内存管理性能是一样的，有时还能更加快速，因为编译器还可以执行某些优化。</p><h1 id="二、weak-的作用"><a href="#二、weak-的作用" class="headerlink" title="二、weak 的作用"></a>二、weak 的作用</h1><p>iOS 开发程序猿都会知晓 weak 关键字的作用是弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为 nil。而如果大量使用附有 weak 修饰符的变量，则会消耗相应的 CPU 资源。所以我们只需要避免循环引用时使用_ _ weak 修饰符。</p><h1 id="三、weak-实现原理"><a href="#三、weak-实现原理" class="headerlink" title="三、weak 实现原理"></a>三、weak 实现原理</h1><p>Runtime 维护了一个 weak 表，用于存储指向某个对象的所有 weak 指针。weak 表其实是一个 hash（哈希）表，Key 是所指对象的地址，Value 是 weak 指针的地址（这个地址的值是所指对象的地址）数组。</p><p>weak 的实现原理可以概括以下三步：</p><p>1、初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。 2、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 3、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。</p><h1 id="章后彩蛋"><a href="#章后彩蛋" class="headerlink" title="章后彩蛋"></a>章后彩蛋</h1><ul><li><p>实现 weak 后，为什么对象释放后会自动为 nil？ runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil 。</p></li><li><p>当 weak 引用指向的对象被释放时，又是如何去处理 weak 指针的呢？ 1、调用 objc_release 2、因为对象的引用计数为 0，所以执行 dealloc 3、在 dealloc 中，调用了_objc_rootDealloc 函数 4、在_objc_rootDealloc 中，调用了 object_dispose 函数 5、调用 objc_destructInstance 6、最后调用 objc_clear_deallocating(重点关注),详细过程如下：</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">objc_clear_deallocating该函数的动作如下：<br><br><span class="hljs-number">1</span>、从<span class="hljs-keyword">weak</span>表中获取废弃对象的地址为键值的记录<br><br><span class="hljs-number">2</span>、将包含在记录中的所有附有 <span class="hljs-keyword">weak</span>修饰符变量的地址，赋值为<span class="hljs-literal">nil</span><br><br><span class="hljs-number">3</span>、将<span class="hljs-keyword">weak</span>表中该记录删除<br><br><span class="hljs-number">4</span>、从引用计数表中删除废弃对象的地址为键值的记录<br><br></code></pre></td></tr></table></figure><p><a href="http://www.cocoachina.com/ios/20170328/18962.html">iOS 底层解析 weak 的实现原理（包含 weak 对象的初始化，引用，释放的分析）</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS -KVO 实现原理</title>
    <link href="/2023/11/27/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2023/11/27/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>KVO（全称：Key-Value Observing），也叫键值监听，是一种观察者设计模式。它提供一种机制。也就是当 KVO 监听某一个对象时，一旦指定的对象的属性被修改后，则其观察者就会接受到通知，进而做出相应的动作。简单的说就是每次指定的被观察的对象的属性被修改后，KVO 就会自动通知相应的观察者了。</p><p>打个比方，有两个对象 A 和 B，B 中有某一个属性 D，A 观察了 B 中属性 D，当属性 D 发生变化的时候，A 收到回调而回调方法中有新的值或者旧的值。</p><p>KVO 其实也是“观察者”设计模式的一种应用。这种模式有利于两个类间的解耦合，尤其是对于 业务逻辑与视图控制 这两个功能的解耦合</p><h1 id="二、KVO-基本原理"><a href="#二、KVO-基本原理" class="headerlink" title="二、KVO 基本原理"></a>二、KVO 基本原理</h1><p>1.KVO 是基于 runtime 机制实现的 2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法内实现真正的通知机制 3.如果原类为 Person，那么生成的派生类名为 NSKVONotifying_Person 4.每个类对象中都有一个 isa 指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将 isa 指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的 setter 方法 5.键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。</p><h1 id="三、-KVO-深入原理："><a href="#三、-KVO-深入原理：" class="headerlink" title="三、 KVO 深入原理："></a>三、 KVO 深入原理：</h1><p>1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象 A 时，KVO 机制动态创建一个新的名为： NSKVONotifying_A 的新类，该类继承自对象 A 的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter  方法，setter  方法会负责在调用原  setter  方法之前和之后，通知所有观察对象属性值的更改情况。</p><p>2.NSKVONotifying_A 类剖析：在这个过程，被观察对象的 isa 指针从指向原来的 A 类，被 KVO 机制修改为指向系统新创建的子类 NSKVONotifying_A 类，来实现当前类属性值改变的监听；</p><p>3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。</p><p>4.（isa 指针的作用：每个对象都有 isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa 指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。）  因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。</p><p>5.子类 setter 方法剖析：KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用 2 个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath  的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath  的属性值已经变更；之后,observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的 setter  方法这种继承方式的注入是在运行时而不是编译时实现的。<br><img src="/images/1814928-335018fa848469d9.webp" alt="NSFileHandle.jpg"></p><p>KVO 原理图</p><h1 id="四、实现步骤"><a href="#四、实现步骤" class="headerlink" title="四、实现步骤"></a>四、实现步骤</h1><p>1、注册观察者</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br>- (<span class="hljs-type">void</span>)addObserver:(<span class="hljs-built_in">NSObject</span> *)observer forKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath options:(<span class="hljs-built_in">NSKeyValueObservingOptions</span>)options context:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> *)context;<br></code></pre></td></tr></table></figure><p>我们来看看每个参数的含义<br><strong>observer</strong></p><p>称为观察者 （这里观察 self.model 对象的属性变化）</p><p><strong>keyPath</strong></p><p>被观察的属性名称(这里观察 model 中 num 属性值的改变),这个值不能为 nil，而且这个值只能是 NSString 类型</p><p><strong>options</strong></p><p>观察属性的新值、旧值等的一些配置（枚举值，可以根据需要设置，例如这里可以使用两项）</p><pre><code class="hljs">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123;  //以字典的形式提供 “更新后新的数据”;  NSKeyValueObservingOptionNew = 0x01,  //以字典的形式提供 “初始对象数据”;  NSKeyValueObservingOptionOld = 0x02,  //观察最初的值（在注册观察服务时会调用一次触发方法）  NSKeyValueObservingOptionInitial API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)) = 0x04,//分别在值修改前后触发方法（即一次修改有两次触发）  NSKeyValueObservingOptionPrior API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)) = 0x08&#125;;</code></pre><p><strong>context</strong></p><p>上下文，可以为 KVO 的回调方法传值（例如设定为一个放置数据的字典，可以作为移除观察者的标示）</p><p>2、实现 KVO 回调方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-comment">//keyPath:属性名称</span><br><span class="hljs-comment">//object:被观察的对象</span><br><span class="hljs-comment">//change:变化前后的值都存储在 change 字典中</span><br><span class="hljs-comment">//context:注册观察者时，context 传过来的值</span><br><br>- (<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-type">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-type">id</span>&gt; *)change context:(<span class="hljs-type">void</span> *)context&#123;<br><br>  <span class="hljs-keyword">if</span>([keyPath isEqualToString:<span class="hljs-string">@&quot;num&quot;</span>] &amp;&amp; object == model) &#123;<br><br>      &#125;<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>3、触发监听</p><blockquote><p>我们设定好接听之后，当改变被监听对象的值时，就可以触发监听回调方法了。但是要注意的是，不能直接使用_变量名直接赋值改变，而应该使用 self.变量名对被监听对象值得修改。这一点主要是因为 _变量名只是直接操作对象指针，sel.变量名是调用 setter 方法操作对象指针，而 KVO 是通过 runtime 实现的，必须调用 setValue:forKey 方法赋值才会触发监听的。</p></blockquote><p>4、移除监听</p><p>在监听完成之后，我们必须将监听移除，否则会导致内存溢出</p><pre><code class="hljs">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));</code></pre><p>一般在 dealloc 方法中调用。这里有一个问题需要了解下，注册和移除是一一对应的，有几个注册就要有几个移除。如果一个类中有多个监听对象，可以有 context 值来区分。</p><p>5、KVO 控制是否自动发送通知</p><p>我们可以在模型类中添加这样一个方法:(返回 YES 表示自动发送通知,返回 NO 表示不自动发送通知)</p><pre><code class="hljs">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key&#123;    return NO;&#125;</code></pre><p>而在外部需要调用 KVO 时,需要在改变属性值的前后加上</p><pre><code class="hljs">[model willChangeValueForKey:@&quot;Value&quot;];-------[model didChangeValueForKey:@&quot;Value&quot;];</code></pre><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><a href="https://github.com/xiaoyeZhang/KVO_Demo.git">Demo</a></h1><p>接下来我们通过例子来简单的实现 KVO</p><p><strong>建立观察者模型（建立 KVO_Model （NSObject）类）</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">KVO_Model</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">assign</span>)<span class="hljs-type">int</span> num;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">assign</span>)<span class="hljs-built_in">NSString</span> *age;<br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure><p><strong>注册监听</strong></p><pre><code class="hljs">    self.model = [[KVO_Model alloc]init];    [self.model addObserver:self forKeyPath:@&quot;num&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld|NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionPrior context:nil];</code></pre><p><strong>实现回调方法</strong></p><pre><code class="hljs">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;    if([keyPath isEqualToString:@&quot;num&quot;] &amp;&amp; object == model) &#123;        // 响应变化处理：UI更新（label文本改变）        self.label.text = [NSString stringWithFormat:@&quot;当前的num值为：%@&quot;,                           [change valueForKey:@&quot;new&quot;]];        for (NSString *key in  change) &#123;            NSLog(@&quot;\\key :%@ key_value:%@&quot;,key,                  [change valueForKey:key]);        &#125;    &#125;&#125;</code></pre><p><strong>改变被监听对象的值</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br>    <span class="hljs-comment">//按一次，使num的值+1</span><br>    self.model.<span class="hljs-built_in">num</span> = self.model.<span class="hljs-built_in">num</span> + <span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>移除 KVO</strong></p><pre><code class="hljs">- (void)dealloc&#123;    [self.model removeObserver:self forKeyPath:@&quot;num&quot; context:nil];&#125;</code></pre><p><strong>模式转换</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">KVO_Model</span></span><br><br>+ (<span class="hljs-type">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="hljs-built_in">NSString</span> *)key&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">//按一次，使num的值+1    [self.model willChangeValueForKey:@&quot;num&quot;];    self.model.num = self.model.num + 1;    [self.model didChangeValueForKey:@&quot;num&quot;];</code></pre><p><a href="http://liumh.com/2015/08/25/ios-know-kvo/">iOS 初探 KVO</a><br><a href="http://zhangbuhuai.com/understanding-kvo/">深入理解 KVO</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS 原生加载PDF文档(主要功能:跳转指定的页码)</title>
    <link href="/2023/11/24/%E5%8E%9F%E7%94%9F%E5%8A%A0%E8%BD%BDPDF%E6%96%87%E6%A1%A3/"/>
    <url>/2023/11/24/%E5%8E%9F%E7%94%9F%E5%8A%A0%E8%BD%BDPDF%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际的开发过程中，我们会遇到一些需要显示PDF的场景，比如官方文件（为了保证原有的格式显示正常，通常会做成PDF来展示），同时也会要求跳转到指定的PDF的页码中,这里我们来讨论一个展示PDF并且调整指定的页码的方式。</p><p>简单的介绍下加载PDF的几种方式(PDF可能是网络加载的，也可能是本地的)</p><ul><li>WKWebView加载本地或者网络pdf文档</li><li>QLPreviewController加载pdf文档</li><li>用CGContext画pdf文档，并结合UIPageViewController展示</li><li>使用第三方框架vfr&#x2F;Reader加载pdf文档</li></ul><p>在这里我使用CGContext加上UICollectionView来实现加载PDF和跳转指定页码,(其他方法暂时不提及)</p><h4 id="第一步-创建UICollectionView"><a href="#第一步-创建UICollectionView" class="headerlink" title="第一步  创建UICollectionView"></a>第一步  创建UICollectionView</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">self.TopHeight</span> = self.navigationController.navigationBar.frame.size.height + [UIApplication sharedApplication].statusBarFrame.size.height<span class="hljs-comment">;</span><br><br><span class="hljs-attr">self.layout</span> = [[UICollectionViewFlowLayout alloc] init]<span class="hljs-comment">;</span><br>    <br><span class="hljs-attr">self.layout.itemSize</span> = CGSizeMake(self.view.bounds.size.width, self.view.frame.size.height-self.TopHeight)<span class="hljs-comment">;</span><br><br><span class="hljs-section">[self.layout setScrollDirection:self.scrollDirection]</span><span class="hljs-comment">;//设置滑动方向为水平方向，也可以设置为竖直方向</span><br>    <br><span class="hljs-attr">self.layout.minimumLineSpacing</span> = <span class="hljs-number">0</span><span class="hljs-comment">;//设置item之间最下行距</span><br>    <br><span class="hljs-attr">self.layout.minimumInteritemSpacing</span> = <span class="hljs-number">0</span><span class="hljs-comment">;//设置item之间最小间距</span><br>    <br><span class="hljs-attr">_CollectionView</span> = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:self.layout]<span class="hljs-comment">;</span><br>    <br><span class="hljs-attr">_CollectionView.backgroundColor</span> = [UIColor whiteColor]<span class="hljs-comment">;</span><br><span class="hljs-attr">_CollectionView.pagingEnabled</span> = self.PDFPagingEnabled<span class="hljs-comment">;//设置集合视图一页一页的翻动</span><br><span class="hljs-attr">_CollectionView.delegate</span> = self<span class="hljs-comment">;</span><br><span class="hljs-attr">_CollectionView.dataSource</span> = self<span class="hljs-comment">;</span><br><br><br><span class="hljs-section">[self.view addSubview:self.CollectionView]</span><span class="hljs-comment">;//将集合视图添加到当前视图上</span><br><br><span class="hljs-section">[self.CollectionView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="hljs-section">    make.top.mas_equalTo(self.TopHeight);</span><br><span class="hljs-section">    make.left.right.equalTo(self.view);</span><br><span class="hljs-section">    make.height.mas_equalTo(self.view.frame.size.height-self.TopHeight);</span><br><span class="hljs-section">&#125;]</span><span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><h4 id="第二步-创建UICollectionViewCell"><a href="#第二步-创建UICollectionViewCell" class="headerlink" title="第二步  创建UICollectionViewCell"></a>第二步  创建UICollectionViewCell</h4><p>在自定义的cell中对showView重写set方法,重写cell视图</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-keyword">for</span>(UIView *tempView <span class="hljs-built_in">in</span> <span class="hljs-variable">_contentScrollView</span>.subviews) &#123;<br>    <br>    [tempView removeFromSuperview];<span class="hljs-comment">//移除_contentScrollView中的所有视图</span><br>    <br>&#125;<br><br><span class="hljs-variable">_showView</span> = showView;<span class="hljs-comment">//赋值</span><br><br>[<span class="hljs-variable">_contentScrollView</span> addSubview:showView];<span class="hljs-comment">//将需要显示的视图添加到_contentScrollView上</span><br><br></code></pre></td></tr></table></figure><h4 id="第三步-读取PDF文件"><a href="#第三步-读取PDF文件" class="headerlink" title="第三步  读取PDF文件"></a>第三步  读取PDF文件</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//用于读取pdf文件</span><br>- (<span class="hljs-built_in">CGPDFDocumentRef</span>)pdfRefByDataByUrl:(<span class="hljs-built_in">NSString</span> *)aFileUrl &#123;<br>    <br>    <span class="hljs-built_in">NSData</span> *pdfData;<br>    <br>    <span class="hljs-keyword">if</span> ([aFileUrl hasPrefix:<span class="hljs-string">@&quot;http://&quot;</span>] || [aFileUrl hasPrefix:<span class="hljs-string">@&quot;https://&quot;</span>]) &#123;<br>     <br>        pdfData = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:[<span class="hljs-built_in">NSURL</span> URLWithString:aFileUrl]];<br><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <br>        pdfData = [<span class="hljs-built_in">NSData</span> dataWithContentsOfFile:aFileUrl];<br><br>    &#125;<br><br>    <span class="hljs-built_in">CFDataRef</span> dataRef = (__bridge_retained <span class="hljs-built_in">CFDataRef</span>)(pdfData);<br><br>    <span class="hljs-built_in">CGDataProviderRef</span> proRef = <span class="hljs-built_in">CGDataProviderCreateWithCFData</span>(dataRef);<br>    <span class="hljs-built_in">CGPDFDocumentRef</span> pdfRef = <span class="hljs-built_in">CGPDFDocumentCreateWithProvider</span>(proRef);<br><br>    <span class="hljs-built_in">CGDataProviderRelease</span>(proRef);<br>    <br>    <span class="hljs-keyword">if</span> (dataRef == <span class="hljs-literal">nil</span>) &#123;<br>    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <br>    &#125;<br>    <br>    <span class="hljs-built_in">CFRelease</span>(dataRef);<br><br><br>    <span class="hljs-keyword">return</span> pdfRef;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第四步-获取所有需要显示的PDF页面"><a href="#第四步-获取所有需要显示的PDF页面" class="headerlink" title="第四步  获取所有需要显示的PDF页面"></a>第四步  获取所有需要显示的PDF页面</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//获取所有需要显示的PDF页面</span><br><br>- (<span class="hljs-type">void</span>)getDataArrayValue &#123;<br>    <br>    size_t totalPages = <span class="hljs-built_in">CGPDFDocumentGetNumberOfPages</span>(_docRef);<span class="hljs-comment">//获取总页数</span><br><br>    <span class="hljs-keyword">self</span>.totalPage= (<span class="hljs-type">int</span>)totalPages;<span class="hljs-comment">//给全局变量赋值</span><br><br>    <span class="hljs-built_in">NSMutableArray</span> *arr = [<span class="hljs-built_in">NSMutableArray</span> new];<br>    <br>    <span class="hljs-comment">//通过循环创建需要显示的PDF页面，并把这些页面添加到数组中</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>; i &lt;= totalPages; i++) &#123;<br><br>        RiderPDFView *view = [[RiderPDFView alloc] initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">self</span>.view.frame.size.width,<span class="hljs-keyword">self</span>.view.frame.size.height-<span class="hljs-keyword">self</span>.TopHeight) documentRef: _docRef andPageNum:i];<br><br>        [arr addObject:view];<br><br>    &#125;<br><br>    <span class="hljs-keyword">self</span>.dataArray= arr;<span class="hljs-comment">//给数据数组赋值</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第五步-创建RiderPDFView视图"><a href="#第五步-创建RiderPDFView视图" class="headerlink" title="第五步  创建RiderPDFView视图,"></a>第五步  创建RiderPDFView视图,</h4><p>在RiderPDFView.m文件中绘制视图</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//重写- (void)drawRect:(CGRect)rect方法</span><br><br>- (<span class="hljs-type">void</span>)drawRect:(<span class="hljs-built_in">CGRect</span>)rect &#123;<br>    <br>    [<span class="hljs-keyword">self</span> drawPDFIncontext:<span class="hljs-built_in">UIGraphicsGetCurrentContext</span>()];<span class="hljs-comment">//将当前的上下文环境传递到方法中，用于绘图</span><br>    <br>&#125;<br><br><span class="hljs-comment">//- (void)drawRect:(CGRect)rect具体的内容</span><br><br>- (<span class="hljs-type">void</span>)drawPDFIncontext:(<span class="hljs-built_in">CGContextRef</span>)context &#123;<br>    <br>    <span class="hljs-built_in">CGContextTranslateCTM</span>(context,<span class="hljs-number">0.0</span>,<span class="hljs-keyword">self</span>.frame.size.height);<br>    <br>    <span class="hljs-built_in">CGContextScaleCTM</span>(context,<span class="hljs-number">1.0</span>, <span class="hljs-number">-1.0</span>);<br><br><span class="hljs-comment">//上面两句是对环境做一个仿射变换，如果不执行上面两句那么绘制出来的PDF文件会呈倒置效果，第二句的作用是使图形呈正立显示，第一句是调整图形的位置，如不执行绘制的图形会不在视图可见范围内</span><br>    <br>    <span class="hljs-built_in">CGPDFPageRef</span>  pageRef =<span class="hljs-built_in">CGPDFDocumentGetPage</span>(documentRef,pageNum);<span class="hljs-comment">//获取需要绘制的页码的数据。两个参数，第一个数传递进来的PDF资源数据，第二个是传递进来的需要显示的页码</span><br>    <br>    <span class="hljs-built_in">CGContextSaveGState</span>(context);<span class="hljs-comment">//记录当前绘制环境，防止多次绘画</span><br>    <br>    <span class="hljs-built_in">CGAffineTransform</span>  pdfTransForm =<span class="hljs-built_in">CGPDFPageGetDrawingTransform</span>(pageRef,kCGPDFCropBox,<span class="hljs-keyword">self</span>.bounds,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>);<span class="hljs-comment">//创建一个仿射变换的参数给函数。第一个参数是对应页数据；第二个参数是个枚举值，我每个都试了一下，貌似没什么区别……但是网上看的资料都用的我当前这个，所以就用这个了；第三个参数，是图形绘制的区域，我设置的是当前视图整个区域，如果有需要，自然是可以修改的；第四个是旋转的度数，这里不需要旋转了，所以设置为0；第5个，传递true，会保持长宽比</span><br>    <br>    <span class="hljs-built_in">CGContextConcatCTM</span>(context, pdfTransForm);<span class="hljs-comment">//把创建的仿射变换参数和上下文环境联系起来</span><br>    <br>    <span class="hljs-built_in">CGContextDrawPDFPage</span>(context, pageRef);<span class="hljs-comment">//把得到的指定页的PDF数据绘制到视图上</span><br>    <br>    <span class="hljs-built_in">CGContextRestoreGState</span>(context);<span class="hljs-comment">//恢复图形状态</span><br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="第六步-加载pdf内容"><a href="#第六步-加载pdf内容" class="headerlink" title="第六步  加载pdf内容"></a>第六步  加载pdf内容</h4><p>在PDFReadViewController.m文件中collectionView的代理方法中加载RiderPDFView视图</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog">CollectionViewCell *<span class="hljs-keyword">cell</span> = [collectionView dequeueReusableCellWithReuseIdentifier:@<span class="hljs-string">&quot;CollectionViewCell&quot;</span> forIndexPath:indexPath];<br><br><span class="hljs-keyword">cell</span><span class="hljs-variable">.cellTapDelegate</span> = self;<span class="hljs-comment">//设置tap事件代理</span><br><br><span class="hljs-keyword">cell</span><span class="hljs-variable">.showView</span> = self<span class="hljs-variable">.dataArray</span>[indexPath<span class="hljs-variable">.row</span>];<span class="hljs-comment">//赋值，设置每个item中显示的内容</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">cell</span>;<br></code></pre></td></tr></table></figure><h1 id="最后-Demo"><a href="#最后-Demo" class="headerlink" title="最后(Demo)"></a>最后(<a href="https://github.com/xiaoyeZhang/PDF-READ">Demo</a>)</h1><p>pdf阅读器已经开源了框架,具体使用方法如下</p><h1 id="第一步：使用CocoaPods导入PDF-READ"><a href="#第一步：使用CocoaPods导入PDF-READ" class="headerlink" title="第一步：使用CocoaPods导入PDF-READ"></a>第一步：使用CocoaPods导入PDF-READ</h1><p>CocoaPods 导入</p><p>  在文件 Podfile 中加入以下内容：</p><pre><code class="hljs">pod &#39;PDF-READ&#39;</code></pre><p>  然后在终端中运行以下命令：</p><pre><code class="hljs">pod install</code></pre><p>  或者这个命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">禁止升级 CocoaPods 的 spec 仓库，否则会卡在 Analyzing dependencies，非常慢<br>  pod install --<span class="hljs-keyword">verbose</span> --<span class="hljs-keyword">no</span>-repo-<span class="hljs-keyword">update</span><br>或者<br>  pod <span class="hljs-keyword">update</span> --<span class="hljs-keyword">verbose</span> --<span class="hljs-keyword">no</span>-repo-<span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><p>  完成后，CocoaPods 会在您的工程根目录下生成一个 .xcworkspace 文件。您需要通过此文件打开您的工程，而不是之前的 .xcodeproj。</p><h1 id="第二步：初始化PDFReadViewController类-同时传入文档地址"><a href="#第二步：初始化PDFReadViewController类-同时传入文档地址" class="headerlink" title="第二步：初始化PDFReadViewController类,同时传入文档地址"></a>第二步：初始化PDFReadViewController类,同时传入文档地址</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">PDFReadViewController *vc = [[PDFReadViewController alloc]<span class="hljs-keyword">init</span>];<br><br>vc.fileUrl = <span class="hljs-string">@&quot;http://172.16.9.159:8888/002.pdf&quot;</span>; <span class="hljs-comment">//不能为空,可以为网络地址,也可以为本的存储地址</span><br><br>[<span class="hljs-meta">self.navigationController pushViewController:vc animated:YES</span>];<br><br><br></code></pre></td></tr></table></figure><h1 id="第三步（可选）：设置阅读模式-横向-或纵向阅读-是否翻页-设置跳转指定的页码"><a href="#第三步（可选）：设置阅读模式-横向-或纵向阅读-是否翻页-设置跳转指定的页码" class="headerlink" title="第三步（可选）：设置阅读模式,横向,或纵向阅读,是否翻页,设置跳转指定的页码"></a>第三步（可选）：设置阅读模式,横向,或纵向阅读,是否翻页,设置跳转指定的页码</h1>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini">  <br><span class="hljs-attr">vc.scrollDirection</span> = UICollectionViewScrollDirectionHorizontal<span class="hljs-comment">; // 横向,或纵向阅读</span><br><br><span class="hljs-attr">vc.PDFPagingEnabled</span> = <span class="hljs-literal">YES</span><span class="hljs-comment">;  // 是否翻页</span><br><br><span class="hljs-attr">vc.item</span> = @<span class="hljs-string">&quot;2&quot;</span><span class="hljs-comment">; // 指定的页码</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/23/hello-world/"/>
    <url>/2023/11/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
